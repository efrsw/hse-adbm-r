x <- runif(10000, -1, 1)
y <- runif(10000, -1, 1)
s
# approx Pi
s = length(a[(a[,1]^2 + a[,2]^2) <= 1]) / 10000
s
a = matrix(runif(20000, -1, 1), ncol = 2)
# approx Pi
s = length(a[(a[,1]^2 + a[,2]^2) <= 1]) / 10000
s
a = table(runif(20000, -1, 1), ncol = 2)
a = data.table(runif(20000, -1, 1), ncol = 2)
a = data.frame(runif(20000, -1, 1), ncol = 2)
a = data.frame(runif(10000, -1, 1), runif(10000, -1, 1))
# approx Pi
s = length(a[(a[,1]^2 + a[,2]^2) <= 1]) / 10000
a
# approx Pi
s = length(a[(a[,1]^2 + a[,2]^2) <= 1]) / 10000
a = data.frame(Column1=runif(10000, -1, 1), Column2=runif(10000, -1, 1))
# approx Pi
s = length(a[(a[,1]^2 + a[,2]^2) <= 1]) / 10000
a = data.frame(1=runif(10000, -1, 1), 2=runif(10000, -1, 1))
a = data.frame(Column1=runif(10000, -1, 1), Column2=runif(10000, -1, 1))
a
a[1]
a[,1]
a[1,1]
a[1,2]
a[1,]
# approx Pi
s = length(a[(a[1,]^2 + a[2,]^2) <= 1]) / 10000
s
(a[1,]^2 + a[2,]^2) <= 1
a[(a[1,]^2 + a[2,]^2) <= 1]
a[(a[1,]^2 + a[2,]^2) <= 1][1]
a[(a[1,]^2 + a[2,]^2) <= 1][2]
a[(a[1,]^2 + a[2,]^2) <= 1]
a = matrix(runif(20000, -1, 1), ncol = 2)
a
points = data.frame(C1=x, C2=y)
points = data.frame(x=x, y=y)
points
p[p < 1]
p = data.frame(x=x, y=y)
p[p < 1]
p[p[1,] < 1]
p[p[1,] < 0.5]
p[p[1,] ^ 2 < 0.1]
p[(p[1,]^2 + p[2,]) <= 1]
s = p[(p[1,]^2 + p[2,]) <= 1]
rm(points)
gc()
s = p[(x^2 + y^2) <= 1]
x <- runif(10000, -1, 1)
y <- runif(10000, -1, 1)
p = data.frame(x=x, y=y)
s = p[(x^2 + y^2) <= 1]
s = p[(x^2 + y^2) <= 1, ]
s / 10000
length(s) / 10000
x <- runif(10000, -1, 1)
y <- runif(10000, -1, 1)
p = data.frame(x=x, y=y)
s = p[(x^2 + y^2) <= 1, ]
length(s) / 10000
t = p[,]
t = p[1,]
length(s[,1]) / 10000
t = matrix(runif(20000, -1, 1), ncol = 2)
t
t[,1]
t[1,]
t[p[,1] < 0.5,]
t[(p[,1]^2 + p[,2]^2) <= 1,]
t = matrix(runif(20000, -1, 1), ncol = 2)
length(t[(p[,1]^2 + p[,2]^2) <= 1,])
b = length(t[(p[,1]^2 + p[,2]^2) <= 1,])
b/20000
s/10000
s = length(p[(x^2 + y^2) <= 1, ])
s/10000
x <- runif(10000, -1, 1)
y <- runif(10000, -1, 1)
p = data.frame(x=x, y=y)
s = length(p[(x^2 + y^2) <= 1, ])
s/10000
t = matrix(runif(20000, -1, 1), ncol = 2)
b = length(t[(p[,1]^2 + p[,2]^2) <= 1,])
b/20000
s = p[(x^2 + y^2) <= 1, ]
s = length(p[(x^2 + y^2) <= 1, ][,1])
s/10000
t = matrix(runif(20000, -1, 1), ncol = 2)
b = length(t[(p[,1]^2 + p[,2]^2) <= 1,])
b/20000
x <- runif(10000, -1, 1)
y <- runif(10000, -1, 1)
p = data.frame(x=x, y=y)
s = length(p[(x^2 + y^2) <= 1, ][,1])
s/10000
t = matrix(runif(20000, -1, 1), ncol = 2)
b = length(t[(p[,1]^2 + p[,2]^2) <= 1,])
b/20000
x <- runif(10000, -1, 1)
y <- runif(10000, -1, 1)
d = data.frame(x=x, y=y)
s = length(p[(x^2 + y^2) <= 1, ][,1])
prob = s/10000
prob * 4
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
prob * 4 # наша оценка
cumsum(p[(x^2 + y^2) <= 1, ][,1])
cumsum(length(p[(x^2 + y^2) <= 1, ][,1])
cumsum(length(p[(x^2 + y^2) <= 1, ][,1]))
cumsum(length(p[(x^2 + y^2) <= 1, ][,1]))
plot(length(p[(x^2 + y^2) <= 1, ][,1]))
plot(length(p[(x^2 + y^2) <= 1, ][,1])/10000)
plot(length(p[(x^2 + y^2) <= 1, ][,1])/10000, log='y')
s = p[(x^2 + y^2) <= 1, ]
x <- runif(10000, -1, 1)
y <- runif(10000, -1, 1)
d = data.frame(x=x, y=y)
s = p[(x^2 + y^2) <= 1, ]
prob = length(s[,1])/10000
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
prob * 4 # наша оценка
s
num_simulations <- 100
num_samples_vector <- seq(100, 10000, by = 100)
pi_estimates <- numeric(length(num_samples_vector))
for (i in 1:length(num_samples_vector)) {
num_samples <- num_samples_vector[i]
pi_estimates[i] <- monte_carlo_pi(num_samples)
}
plot(num_samples_vector, pi_estimates, type = "l", col = "blue", xlab = "Число бросков", ylab = "Оценка Pi")
num_simulations <- 100
num_samples_vector <- seq(100, 10000, by = 100)
pi_estimates <- numeric(length(num_samples_vector))
for (i in 1:length(num_samples_vector)) {
num_samples <- num_samples_vector[i]
pi_estimates[i] <- monte_carlo_pi(num_samples)
}
plot(num_samples_vector, pi_estimates, type = "l", col = "blue", xlab = "Число бросков", ylab = "Оценка Pi")
#### практика ####
x = runif(1, -5, 5)
sin(x)
k = 0:10
mysin = (-1)^k * (x^(2*k + 1) / factorial(2*k + 1))
n_sims = seq(100, 1000, 100)
n_sims = seq(100, 10000, 100)
s = length(data.frame(runif(10000, -1, 1), runif(10000, -1, 1))[(x^2 + y^2) <= 1, ][,1])/1
p = data.frame(
x = runif(n_sims, -1, 1),
y = runif(n_sims, -1, 1)
)[(x^2 + y^2) <= 1][,1]/n_sims
p = data.frame(
x = runif(n_sims, -1, 1),
y = runif(n_sims, -1, 1)
)[(x^2 + y^2) <= 1][,1]/n_sims
p = data.frame(
x = runif(n_sims, -1, 1),
y = runif(n_sims, -1, 1)
)[(x^2 + y^2) <= 1][,1]
n_sims = seq(100, 10000, 100)
p = data.frame(
x = runif(n_sims, -1, 1),
y = runif(n_sims, -1, 1)
)[(x^2 + y^2) <= 1][,1]
p = data.frame(
x = runif(n_sims, -1, 1),
y = runif(n_sims, -1, 1)
)
n_sims = seq(100, 10000, 100)
n_sims
p = runif(n_sims, -1, 1)
P
p
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
calc_prob(10000) * 4 # наша оценка
calc_prob = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = p[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / 10000
return(prob)
}
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
calc_prob(10000) * 4 # наша оценка
calc_prob = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = p[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / 10000
return(prob)
}
calc_prob(1000)
calc_prob = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / 10000
return(prob)
}
calc_prob(1000)
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
calc_prob(10000) * 4 # наша оценка
map(n_sims, calc_prob())
?map
?map()
?matrix
Map(calc_prob, n_sims)
Map(calc_prob * 4, n_sims)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / 10000
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000)
estims = Map(calc_prob, n_sims)
plot(estims)
plot(1:100, estims)
estimate_pi(10000) # наша оценка на 10000
n_sims = seq(100, 10000, 100)
estims = Map(estimate_pi, n_sims)
plot(1:100, estims)
plot(n_sims, estims)
n_sims = seq(100, 10000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
plot(n_sims, estims)
estimate_pi(10000) # наша оценка на 10000
estimate_pi(100)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / num_samples
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000) # наша оценка на 10000
estimate_pi(100)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / num_samples
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000) # наша оценка на 10000
estimate_pi(100)
n_sims = seq(100, 10000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
n_sims = seq(100, 100000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
pi
plot(1:100000, pi)
lines(x=n_sims)
plot(n_sims, estims)
lines(x=n_sims)
lines(x=1:10000, y=rep(pi, 10000), col = "red")
lines(x=1:10000, y=rep(pi, 100000), col = "red")
lines(x=1:100000, y=rep(pi, 100000), col = "red")
lines(x=1:100000, y=rep(pi, 100000),
col = "red",
lwd = 2)
lines(x=1:100000, y=rep(pi, 100000),
col = "red",
lwd = 2,
labels("PI"))
lines(x=1:100000, y=rep(pi, 100000),
col = "red",
lwd = 2,
labels("PI"))
lines(x=1:100000, y=rep(pi, length(x)),
col = "red",
lwd = 2)
plot(n_sims, estims)
x = 1: 100000
lines(x=x, y=rep(pi, x),
col = "red",
lwd = 2)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / num_samples
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000) # наша оценка на 10000
estimate_pi(100)
n_sims = seq(100, 100000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
x = 1: 100000
lines(x=x, y=rep(pi, x),
col = "red",
lwd = 2)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / num_samples
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000) # наша оценка на 10000
n_sims = seq(100, 100000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
x = 1:100000
lines(x=x, y=rep(pi, len(x)),
col = "red",
lwd = 2)
lines(x=x, y=rep(pi, length(x)),
col = "red",
lwd = 2)
lines(x=n_sims, y=rep(pi, length(x)),
col = "red",
lwd = 2)
lines(x=1:100000, y=rep(pi, 100000),
col = "red",
lwd = 2)
plot(n_sims, estims)
lines(x=1:100000, y=rep(pi, 100000),
col = "red",
lwd = 2)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / num_samples
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000) # наша оценка на 10000
n_sims = seq(100, 100000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
lines(x=1:100000, y=rep(pi, 100000),
col = "red",
lwd = 2)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / num_samples
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000) # наша оценка на 10000
n_sims = seq(100, 10000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
lines(x=1:10000, y=rep(pi, 10000),
col = "red",
lwd = 2)
estimate_pi = function(num_samples) {
x = runif(num_samples, -1, 1)
y = runif(num_samples, -1, 1)
d <- data.frame(x=x, y=y)
s = d[(x^2 + y^2) <= 1, ]
prob = length(s[,1]) / num_samples
# Площадь квадрата = 4*r^2, площадь круга = p*r^2.
# Вероятность точки = площадь круга / площадь квадрата
# p = 4 * вероятность точки
return(prob * 4)
}
estimate_pi(10000) # наша оценка на 10000
n_sims = seq(100, 15000, 100)
estims = Map(estimate_pi, n_sims)
plot(n_sims, estims)
lines(x=1:15000, y=rep(pi, 15000),
col = "red",
lwd = 2)
install.packages('ape')
install.packages("ape")
library(ape)
seq = ape::read.dna("./sequence.fasta", format="fasta")
setwd("C:/dev/hse-adbm-r/seminar_4/")
seq = ape::read.dna("./sequence.fasta", format="fasta")
str(seq)
str(seq["chr"])
seq["chr"]
character(seq["chr"])
seq["chr"]
substr(seq["chr"], 1, 5)
substr(seq["chr"], 1, 6)
substr(seq, 1, 6)
substr(seq$chr, 1, 6)
substr(seq["chr"], 1, 6)
seq["chr"]
co = function(st, let) {
m = gregexpr(let, st)
return(sum(unlist(m) != -1))
}
co(seq["chr"], "aaaa")
stq(seq)
str(seq)
seq[1, 1:5132068]
str(seq[1, 1:5132068])
str(seq)
str(seq)['DNAbin']
seq["chr"]
seq["chr"][1, 1:10]
seq["chr"][1, ]
seq["chr"]
substr(seq["chr"], 1, 1)
as.list(seq)
as.list(seq)[1,]
as.list(seq)
labels(seq)
as.character(seq)
gc()
library(ape)
seq = ape::read.dna("./sequence.fasta", format="fasta")
st = as.character(seq)
st
st[1:5]
st[1,][1:5]
st[1, ]
paste(st[1, ], collapse="")[1:5]
paste(st[1, ], collapse="")
st = paste(as.character(seq)[1, ], collapse = "")[1, ]
st = paste(as.character(seq)[1, ], collapse = "")[1]
nchar(st)
res = list()
res[0] = "aaaa"
View(res)
res[[0]] = "aaaa"
res["aaaa"] = 0
res["bbbb"] = 1
max(res)
max(res[1, ])
co(st, cw)
co(st, "aaaa")
co = function(st, let) {
m = gregexpr(let, st)
return(sum(unlist(m) != -1))
}
co(st, "aaaa")
gc()
install.packages('ape')
install.packages("ape")
